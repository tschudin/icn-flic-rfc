



ICNRG Working Group                                          C. Tschudin
Internet-Draft                                       University of Basel
Intended status: Informational                        September 07, 2015
Expires: March 10, 2016


                    ICN File-Like Collection (FLIC)
                      draft-tschudin-icnrg-flic-00

Abstract

   This document describes a bare bones "index table"-approach for
   organizing a set of ICN data objects into a large, File-LIke
   Collection (FLIC).

   At the core of this collection is a so called manifest which acts as
   the collection's root node.  The manifest contains an index table
   with pointers, each pointer being a hash value pointing to either a
   final data block or another index table node.  Data can also be
   embedded (in case of a small collection), permitting to use a
   manifest just for annotating some data e.g. with its timestamp or
   decryption key information.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at http://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on March 10, 2016.

Copyright Notice

   Copyright (c) 2015 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of



Tschudin                 Expires March 10, 2016                 [Page 1]

Internet-Draft                  ICN-FLIC                  September 2015


   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   2
     1.1.  FLIC as a Distributed Data Structure  . . . . . . . . . .   2
     1.2.  Design goals  . . . . . . . . . . . . . . . . . . . . . .   3
   2.  File-LIke Collection (FLIC) Format  . . . . . . . . . . . . .   4
     2.1.  FLIC format in EBN  . . . . . . . . . . . . . . . . . . .   4
     2.2.  Use of hash-valued pointers . . . . . . . . . . . . . . .   5
     2.3.  Sparse files and long sequences of zeros  . . . . . . . .   5
     2.4.  Reconstructing the collection's data  . . . . . . . . . .   5
     2.5.  MetaData  . . . . . . . . . . . . . . . . . . . . . . . .   5
   3.  Encoding  . . . . . . . . . . . . . . . . . . . . . . . . . .   6
     3.1.  Encoding for CCNx . . . . . . . . . . . . . . . . . . . .   6
     3.2.  Encoding for NDN  . . . . . . . . . . . . . . . . . . . .   6
     3.3.  No chunking . . . . . . . . . . . . . . . . . . . . . . .   6
     3.4.  Encoding strategies . . . . . . . . . . . . . . . . . . .   6
     3.5.  Appending to a FLIC . . . . . . . . . . . . . . . . . . .   7
   Author's Address  . . . . . . . . . . . . . . . . . . . . . . . .   7

1.  Introduction

1.1.  FLIC as a Distributed Data Structure

   One figure




















Tschudin                 Expires March 10, 2016                 [Page 2]

Internet-Draft                  ICN-FLIC                  September 2015


                                          manifest
     +--------------------------------------------+
     | /icn/name/of/this/flic                     |
     |                                            |
     | data:                                      |
     |   sequence of                              |
     |     hash-valued pointers, or embedded data |
     |                   \  \       +------+      |
     | metadata:          \  \      | data |      |
     |   sequence of       \  \     +------+      |
     |     key-value pairs  \  \                  |
     +-----------------------|--\-----------------+
                             |   \                  node
                       leaf  v    `------> +------------+
                      +------+             | seq of     |
                      | data |             |   pointers |
                      +------+             |     \  \   |
                                           +------\--\--+
                                                   vvvv

         Figure 1: A FLIC manifest and its directed acyclic graph

1.2.  Design goals

   o  Copy the proven UNIX inode concept:

      *  index tables and memory pointers (tree)

      *  a single inode block can represent a small file (embedded data)

      *  sparse files

   o  ICN optimizations:

      *  block-level deduplification (leads to a directed acyclic graph,
         DAG)

      *  encode series of zero bytes

      *  eliminate reference to chunk numbering schemata (hash values
         only)

   o  Limitations

      *  all data leafs must be present at manifest creation time

      *  only the manifest ICN object has metadata (encryption key info,
         timestamps etc), which thus applies to all blocks of the DAG.



Tschudin                 Expires March 10, 2016                 [Page 3]

Internet-Draft                  ICN-FLIC                  September 2015


   o  Potential extensions (for study):

      *  Enhance the manifest such that it can serve as a "database
         cursor" or as a cursor over a time series, e.g. having entries
         for "previous" and "next" collections.

2.  File-LIke Collection (FLIC) Format

2.1.  FLIC format in EBN

     Manifest = RootNode MetaData
     RootNode = Node | EncrNode
     Node = *([RepeatCnt] (Pointer | NoneByte | ZeroByte | LeafData]))

     Pointer = LeafDigest | EncrLeafDigest | NodeDigest | EncrNodeDigest
     LeafData = Blob
     Leaf = ICNobject(LeafData)
     EncrLeaf = ICNobject(Blob)
     EncrNode = ICNobject(Blob)
     MetaData = *(KeyString Blob)

   Description:

   o  A manifest consists of a root node and optionally a meta-data
      section

   o  The root node is either in clear ("Node"), or encrypted
      ("EncrNode")

   o  A Node is a sequence of four possible Node entry types:

      *  pointer (see below)

      *  None, meaning that the collection contains an absent byte

      *  Zero, meaning that the collection contains a zero byte

      *  LeafData, the actual bytes as part of the collection
         ("embedding")

   o  Optionally, a Node entry can be preceeded by a count specifying
      how often the subsequent node entry has to be repeated in order to
      reconstruct the collection.

   o  A Pointer has one of the following four types:

      *  LeafDigest = hash value of an ICN data object




Tschudin                 Expires March 10, 2016                 [Page 4]

Internet-Draft                  ICN-FLIC                  September 2015


      *  NodeDigest = hash value of an ICN data object hosting a Node

      *  the two encrypted forms thereof

      Note that the encoding of pointers must represent the type
      information such that a reader of the index table learns what the
      pointer points at (and how these bytes have to be interpreted).

   o  MetaData is organized as a sequence of key-value pairs.

2.2.  Use of hash-valued pointers

   FLIC's "Node" data structure is a generalized index table as it is
   known from file systems.  The pointers, which in an OS typically are
   harddisk block numbers, are replaced by hash values of other ICN
   objects.  These ICN objects contain either other nodes, or leafs.
   Leafs contain the actual data of the collection.

   FLIC makes use of "nameless ICN object" where the network is tasked
   with fetching an object based on its digest only.  The interest for
   such an object consists of a routing hint (locator) plus the given
   digest value.

2.3.  Sparse files and long sequences of zeros

   FLIC supports "files with holes" e.g., memory dumps where some
   regions are undefined because not present at run-time.  This is
   achieved via the NoneByte entry in the Node, preceed by a count
   specifying how many bytes are missing.

   Similarily, long streches of zeros can be compressed to one ZeroByte
   entry with a preceediung count for the length of such a stretch.

2.4.  Reconstructing the collection's data

   Default traversal strategy: Starting from the manifest and its root
   index table, the consumer has to traverse the tree (or DAG) in a
   depth-first fashion.  Each encountered leaf, embedded leaf, or
   ZeroByte entry contributes to the collection's bytes in that
   traversed sequence.

2.5.  MetaData

   A FLIC's MetaData is organized as a sequence of key-value pairs, keys
   being human-readable strings and their associated values being an
   opaque byte sequence.

   Known entries (=well defined names), all are optional:



Tschudin                 Expires March 10, 2016                 [Page 5]

Internet-Draft                  ICN-FLIC                  September 2015


* creation date (UTC)
* locator value (if different from the manifest's name)
* info regarding applicable decryption key(s)
* ICN name towards the next ICN data object containing more metadata
  (can also be used to share large metadata sections across FLICs)
* total length in bytes
* whether a strict block size is used for leafs
* explicit traversal strategies in form of a pointer to an alternate DAG
  (for the same data) e.g., reverse block order, block sub-sampling
* ICN name for a "directory object" that refers to this FLIC
* resource forks (as in Apple's file system)
* etc

3.  Encoding

3.1.  Encoding for CCNx

   use hashRestriction as selector

   how pointers etc are encoded in TLV ...

3.2.  Encoding for NDN

   use implicitDigest name component as selector

   how pointers etc are encoded in TLV ...

3.3.  No chunking

   None of the ICN objects used in FLIC are allowed to be chunked,
   including the manifest.  The smallest possible complete manifest
   contains one pointer to the ICN object containing the topmost index
   table (or leaf) plus a metadata section having a single entry or the
   actucal metadata ICn object.

3.4.  Encoding strategies

   FLIC's Node+Leaf data structures encode a tree or directed acyclic
   graph.  This leaves it open how to balance the graph during its
   encoding.  An extreme layout would be a chain of nodes, each having a
   single pointer to a leaf plus a continuation pointer for the next
   node.  The opposit layout would be a master index table pointing to
   many leafs or sub-tables such as to minimize the tree's height.

   For performance reasons it is suggested to follow a chain pattern
   where each index table node in the chain has at least 10 to 20
   pointers to leafs.




Tschudin                 Expires March 10, 2016                 [Page 6]

Internet-Draft                  ICN-FLIC                  September 2015


3.5.  Appending to a FLIC

   Adding data to a FLIC means creating a new manifest with a new top-
   level index table.  If the original manifest is not too large, its
   top-level index table can be used as starting point for the new one
   which is extended by one leaf pointer.  In any case a new manifest
   object is created which also needs a new name.

   Note that the new manifest's name usually will differ (e.g. in the
   version name component) and that the new manifest might need to carry
   an explicit locator entry in the metadata section in order to make
   the (old) leaf objects accessible.

Author's Address

   Christian Tschudin
   University of Basel

   Email: christian.tschudin@unibas.ch
































Tschudin                 Expires March 10, 2016                 [Page 7]
