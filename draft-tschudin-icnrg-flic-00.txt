



ICNRG Working Group                                          C. Tschudin
Internet-Draft                                       University of Basel
Intended status: Informational                        September 07, 2015
Expires: March 10, 2016


                    ICN File-Like Collection (FLIC)
                      draft-tschudin-icnrg-flic-00

Abstract

   This document describes a bare bones "index table"-approach for
   organizing a set of ICN data objects into a large, File-LIke
   Collection (FLIC).

   At the core of this collection is a so called manifest which acts as
   the collection's root node.  The manifest contains an index table
   with pointers, each pointer being a hash value pointing to either a
   final data block or another index table node.  Data can also be
   embedded (in case of a small collection), permitting to use a
   manifest just for annotating some data e.g. with its timestamp or
   decryption key information.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at http://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on March 10, 2016.

Copyright Notice

   Copyright (c) 2015 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of



Tschudin                 Expires March 10, 2016                 [Page 1]

Internet-Draft                  ICN-FLIC                  September 2015


   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   2
     1.1.  FLIC as a Distributed Data Structure  . . . . . . . . . .   2
     1.2.  Design goals  . . . . . . . . . . . . . . . . . . . . . .   3
   2.  File-LIke Collection (FLIC) Format  . . . . . . . . . . . . .   4
     2.1.  FLIC format in EBN  . . . . . . . . . . . . . . . . . . .   4
     2.2.  Use of hash-valued pointers . . . . . . . . . . . . . . .   4
     2.3.  Creating the FLIC . . . . . . . . . . . . . . . . . . . .   5
     2.4.  Reconstructing the collection's data  . . . . . . . . . .   5
     2.5.  Metadata  . . . . . . . . . . . . . . . . . . . . . . . .   6
   3.  Encoding  . . . . . . . . . . . . . . . . . . . . . . . . . .   6
     3.1.  Encoding for CCNx . . . . . . . . . . . . . . . . . . . .   6
     3.2.  Encoding for NDN  . . . . . . . . . . . . . . . . . . . .   6
     3.3.  No chunking . . . . . . . . . . . . . . . . . . . . . . .   7
     3.4.  Encoding strategies . . . . . . . . . . . . . . . . . . .   7
     3.5.  Appending to a FLIC . . . . . . . . . . . . . . . . . . .   7
   Author's Address  . . . . . . . . . . . . . . . . . . . . . . . .   7

1.  Introduction

1.1.  FLIC as a Distributed Data Structure

   One figure




















Tschudin                 Expires March 10, 2016                 [Page 2]

Internet-Draft                  ICN-FLIC                  September 2015


                                          manifest
     +--------------------------------------------+
     | /icn/name/of/this/flic                     |
     |                                            |
     | hashgroup:                                 |
     |   metadata:                                |
     |     block size, total tree size,           |
     |     overall digest, locator, etc.          |
     |   sequence hash-valued pointers            |
     |                   \  \                     |
     +--------------------|--\--------------------+
                          |   \                   node
                     leaf v    `-------> +------------+
                    +------+             | seq of     |
                    | data |             |   pointers |
                    +------+             |     \  \   |
                                         +------\--\--+
                                                 vvvv

         Figure 1: A FLIC manifest and its directed acyclic graph

1.2.  Design goals

   o  Copy the proven UNIX inode concept:

      *  index tables and memory pointers (tree)

      *  a single inode block can represent a small file (embedded data)

      *  blocks of a node are equally sized

   o  ICN optimizations:

      *  block-level deduplification (leads to a directed acyclic graph,
         DAG)

      *  eliminate reference to chunk numbering schemata (hash values
         only)

      *  one manifest signature covers all elements, including auxiliary
         data structures, of the full collection.

   o  Limitations

      *  all data leafs must be present at manifest creation time
         (otherwise one cannot compute the pointers)





Tschudin                 Expires March 10, 2016                 [Page 3]

Internet-Draft                  ICN-FLIC                  September 2015


      *  only the root manifest has metadata (encryption key info,
         timestamps etc), which thus applies to all blocks of the DAG.

   o  Potential extensions (for study):

      *  Enhance the manifest such that it can serve as a "database
         cursor" or as a cursor over a time series, e.g. having entries
         for "previous" and "next" collections.

2.  File-LIke Collection (FLIC) Format

2.1.  FLIC format in EBN

      ManifestMsg := Name? HashGroup+
      HashGroup   := MetaData? (DataPointer | ManifestPtr)+
      DataPointer := HashValue
      ManifestPtr := HashValue
      HashValue   := OCTET[32]

      MetaData    := Property*
      Property    := Locator | DataBlockSize | OverallDataSize |
                     OverallDataSHA256Digest | ...

   Description:

   o  A manifest consists of a sequence of hash groups, each with
      optional network-layer meta-data, e.g., the overall digest of the
      data and the tree node block size

   o  A hash group contains a sequence of data or manifest pointers.
      Note that the encoding of pointers must represent the type
      information such that a reader of the index table learns what the
      pointer points at (and how these bytes have to be interpreted).

   o  Application data is stored in leaves of the tree-not in manifest
      nodes.

   o  Manifests may be optionally encrypted separately of the encoding.

2.2.  Use of hash-valued pointers

   FLIC's tree data structure is a generalized index table as it is
   known from file systems.  The pointers, which in an OS typically are
   harddisk block numbers, are replaced by hash values of other ICN
   objects.  These ICN objects contain either other nodes, or leafs.
   Leafs contain the actual data of the collection.





Tschudin                 Expires March 10, 2016                 [Page 4]

Internet-Draft                  ICN-FLIC                  September 2015


   FLIC makes use of "nameless ICN object" where the network is tasked
   with fetching an object based on its digest only.  The interest for
   such an object consists of a routing hint (locator) plus the given
   digest value.

2.3.  Creating the FLIC

   FLICs are created from existing application data.  The data is first
   chunked into the desired block size.  The data blocks are then
   inserted into Content Objects whose hashes are computed.  These
   hashes are then iteratively added to manifest nodes to build the
   tree.

   A pseudocode description for producing is below.

Input:
    Application data D of size |D| (bytes)
    Maximum number of pointers P
    Block size B (in bytes)
    Root name N
Output: FLIC root node

1. Starting from the end, split D into m = ceil(|D|/B) blocks of size
B--Dm,..,D1. If |D| is not a multiple of B then D1 will not contain B bytes.
2. Create an empty manifest node M.
3. For i = m downto 1 do
4.     Compute d = H(Di)
5.     Add d to M with type "data"
6.     If |M| >= P then
7.         Compute d = H(M)
8.         Create a new empty manifest node M'
9.         Add d to M' with type "manifest"
10.        Set M to M'
11. Add the name N to M
12. Sign M
13. Return M

2.4.  Reconstructing the collection's data

   FLIC trees are skewed by default.  This enables retrieval and
   reconstruction to exploit tail recursion to minimize memory usage.
   To fetch the data associated with a FLIC manifest, the receiver
   iterates over each data pointer in a node and sends a corresponding
   hash-based interest.  Once the final manifest pointer is reached, the
   receiver recurses to retrieve the data contained inside that
   manifest.  The collection data is represented as the concatenation of
   data leaves from this post-order traversal strategy.




Tschudin                 Expires March 10, 2016                 [Page 5]

Internet-Draft                  ICN-FLIC                  September 2015


   A pseudocode description for fetching is below.

   Input: A FLIC manifest node M
   Output: Application data D of size |D| (bytes)

   1. Set D to nil
   2. Set Ptrs to the list of pointers in M
   2. For each pointer p in Ptrs do
   3.     If p is a "data" pointer then
   4.         Send an interest for p and recover D'
   5.         Set D to D || D'
   6.     Else
   7.         Send an interest for p and recover M'
   8.         Append all pointers in M' to Ptrs
   9. Return D

   Note that the root manifest node M will usually contain the overall
   data size to allow receivers to allocate enough memory to store the
   resulting data.

2.5.  Metadata

   Each hash group in a manifest may carry optional network-level
   metadata.  The list of available metadata is below.

   * locator value (if different from the manifest's name)
   * total length in bytes
   * child node block size
   * overall application data digest
   * etc

3.  Encoding

3.1.  Encoding for CCNx

   use hashRestriction as selector

   how pointers etc are encoded in TLV ...

3.2.  Encoding for NDN

   use implicitDigest name component as selector

   how pointers etc are encoded in TLV ...







Tschudin                 Expires March 10, 2016                 [Page 6]

Internet-Draft                  ICN-FLIC                  September 2015


3.3.  No chunking

   None of the ICN objects used in FLIC are allowed to be chunked,
   including the manifest.  The smallest possible complete manifest
   contains one pointer to the ICN object containing the topmost index
   table (or leaf) plus a metadata section having a single entry or the
   actucal metadata ICn object.

3.4.  Encoding strategies

   FLIC's Node+Leaf data structures encode a tree or directed acyclic
   graph.  This leaves it open how to balance the graph during its
   encoding.  An extreme layout would be a chain of nodes, each having a
   single pointer to a leaf plus a continuation pointer for the next
   node.  The opposite layout would be a master index table pointing to
   many leafs or sub-tables such as to minimize the tree's height.

   For performance reasons it is suggested to follow a chain pattern
   where each index table node in the chain has at least 10 to 20
   pointers to leafs.

3.5.  Appending to a FLIC

   Adding data to a FLIC means creating a new manifest with a new top-
   level index table.  If the original manifest is not too large, its
   top-level index table can be used as starting point for the new one
   which is extended by one leaf pointer.  In any case a new manifest
   object is created which also needs a new name.

   Note that the new manifest's name usually will differ (e.g. in the
   version name component) and that the new manifest might need to carry
   an explicit locator entry in the metadata section in order to make
   the (old) leaf objects accessible.

Author's Address

   Christian Tschudin
   University of Basel

   Email: christian.tschudin@unibas.ch











Tschudin                 Expires March 10, 2016                 [Page 7]
