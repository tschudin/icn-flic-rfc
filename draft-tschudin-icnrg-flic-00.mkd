---
title: ICN File-Like Collection (FLIC)
abbrev: ICN-FLIC
docname: draft-tschudin-icnrg-flic-00
date: 2015-09-07
category: info

ipr: trust200902
area: General
workgroup: ICNRG Working Group
keyword: Internet-Draft

stand_alone: yes
pi: [toc, sortrefs, symrefs]

author:
 -
    ins: C. Tschudin
    name: Christian Tschudin
    organization: University of Basel
    email: christian.tschudin@unibas.ch

normative:
---  RFC2119:
---  RFC3986:
---  RFC4086:
---  RFC4648:

informative:
---  RFC5389:
---  I-D.ietf-behave-turn:
---  STUNT:
---    target: http://deusty.blogspot.com/2007/09/stunt-out-of-band-channels.html
---    title: STUNT & out-of-band channels
---    author:
---      name: Robbie Hanson
---      ins: R. Hanson
---    date: 2007-09-17
---  I-D.meyer-xmpp-e2e-encryption:
---  I-D.ietf-xmpp-3920bis:

--- abstract

This document describes a bare bones "index table"-approach for
organizing a set of ICN data objects into a large, File-LIke
Collection (FLIC).

At the core of this collection is a so called manifest which acts as
the collection's root node. The manifest contains an index table with
pointers, each pointer being a hash value pointing to either a final
data block or another index table node. Data can also be embedded (in case
of a small collection), permitting to use a manifest just for annotating
some data e.g. with its timestamp or decryption key information.

--- middle

Introduction        {#problems}
============

FLIC as a Distributed Data Structure
------------------------------------

One figure

~~~
                                       manifest
  +--------------------------------------------+
  | /icn/name/of/this/flic                     |
  |                                            |
  | hashgroup:                                 |
  |   metadata:                                |
  |     block size, total tree size,           |
  |     overall digest, locator, etc.          |
  |   sequence hash-valued pointers            |
  |                   \  \                     |
  +--------------------|--\--------------------+
                       |   \                   node
                  leaf v    `-------> +------------+
                 +------+             | seq of     |
                 | data |             |   pointers |
                 +------+             |     \  \   |
                                      +------\--\--+
                                              vvvv
~~~
{: #manifest title="A FLIC manifest and its directed acyclic graph"}

Design goals
------------

* Copy the proven UNIX inode concept:
  * index tables and memory pointers (tree)
  * a single inode block can represent a small file (embedded data)
  * blocks of a node are equally sized

* ICN optimizations:
  * block-level deduplification (leads to a directed acyclic graph, DAG)
  * eliminate reference to chunk numbering schemata (hash values only)
  * one manifest signature covers all elements, including auxiliary
    data structures, of the full collection.

* Limitations
  * all data leafs must be present at manifest creation time (otherwise
    one cannot compute the pointers)
  * only the root manifest has metadata (encryption key info,
    timestamps etc), which thus applies to all blocks of the DAG.

* Potential extensions (for study):
  * Enhance the manifest such that it can serve as a "database cursor"
    or as a cursor over a time series, e.g. having entries for "previous"
    and "next" collections.


File-LIke Collection (FLIC) Format
======================================

FLIC format in EBN
------------------

~~~
   ManifestMsg := Name? HashGroup+
   HashGroup   := MetaData? (DataPointer | ManifestPtr)+
   DataPointer := HashValue
   ManifestPtr := HashValue
   HashValue   := OCTET[32]

   MetaData    := Property*
   Property    := Locator | DataBlockSize | OverallDataSize |
                  OverallDataSHA256Digest | ...
~~~

Description:

* A manifest consists of a sequence of hash groups, each with optional
  network-layer meta-data, e.g., the overall digest of the data and the
  tree node block size

* A hash group contains a sequence of data or manifest pointers.
  Note that the encoding of pointers must represent the type information
  such that a reader of the index table learns what the pointer points
  at (and how these bytes have to be interpreted).

* Application data is stored in leaves of the tree--not in manifest nodes.

* Manifests may be optionally encrypted separately of the encoding.

Use of hash-valued pointers
---------------------------

FLIC's tree data structure is a generalized index table as it is
known from file systems. The pointers, which in an OS typically are
harddisk block numbers, are replaced by hash values of other ICN
objects. These ICN objects contain either other nodes, or leafs. Leafs
contain the actual data of the collection.

FLIC makes use of "nameless ICN object" where the network is tasked
with fetching an object based on its digest only. The interest for
such an object consists of a routing hint (locator) plus the given
digest value.

Creating the FLIC
-----------------

FLICs are created from existing application data. The data is first chunked
into the desired block size. The data blocks are then inserted into Content
Objects whose hashes are computed. These hashes are then iteratively added
to manifest nodes to build the tree.

A pseudocode description for producing is below.

~~~
Input:
    Application data D of size |D| (bytes)
    Maximum number of pointers P
    Block size B (in bytes)
    Root name N
Output: FLIC root node

1. Starting from the end, split D into m = ceil(|D|/B) blocks of size
B--Dm,..,D1. If |D| is not a multiple of B then D1 will not contain B bytes.
2. Create an empty manifest node M.
3. For i = m downto 1 do
4.     Compute d = H(Di)
5.     Add d to M with type "data"
6.     If |M| >= P then
7.         Compute d = H(M)
8.         Create a new empty manifest node M'
9.         Add d to M' with type "manifest"
10.        Set M to M'
11. Add the name N to M
12. Sign M
13. Return M
~~~

Reconstructing the collection's data
------------------------------------

FLIC trees are skewed by default. This enables retrieval and reconstruction to
exploit tail recursion to minimize memory usage. To fetch the data associated
with a FLIC manifest, the receiver iterates over each data pointer in a node
and sends a corresponding hash-based interest. Once the final manifest pointer is
reached, the receiver recurses to retrieve the data contained inside that manifest.
The collection data is represented as the concatenation of data leaves from this
post-order traversal strategy.

A pseudocode description for fetching is below.

~~~
Input: A FLIC manifest node M
Output: Application data D of size |D| (bytes)

1. Set D to nil
2. Set Ptrs to the list of pointers in M
2. For each pointer p in Ptrs do
3.     If p is a "data" pointer then
4.         Send an interest for p and recover D'
5.         Set D to D || D'
6.     Else
7.         Send an interest for p and recover M'
8.         Append all pointers in M' to Ptrs
9. Return D
~~~

Note that the root manifest node M will usually contain the overall data size
to allow receivers to allocate enough memory to store the resulting data.

Metadata
--------

Each hash group in a manifest may carry optional network-level metadata.
The list of available metadata is below.

~~~
* locator value (if different from the manifest's name)
* total length in bytes
* child node block size
* overall application data digest
* etc
~~~

Encoding
========

Encoding for CCNx
-----------------

use hashRestriction as selector

how pointers etc are encoded in TLV ...


Encoding for NDN
----------------

use implicitDigest name component as selector

how pointers etc are encoded in TLV ...


No chunking
-----------

None of the ICN objects used in FLIC are allowed to be chunked,
including the manifest. The smallest possible complete manifest
contains one pointer to the ICN object containing the topmost index
table (or leaf) plus a metadata section having a single entry or the
actucal metadata ICn object.

Encoding strategies
-------------------

FLIC's Node+Leaf data structures encode a tree or directed acyclic
graph. This leaves it open how to balance the graph during its
encoding. An extreme layout would be a chain of nodes, each having a
single pointer to a leaf plus a continuation pointer for the next
node. The opposite layout would be a master index table pointing to
many leafs or sub-tables such as to minimize the tree's height.

For performance reasons it is suggested to follow a chain pattern
where each index table node in the chain has at least 10 to 20
pointers to leafs.

Appending to a FLIC
-------------------

Adding data to a FLIC means creating a new manifest with a new
top-level index table. If the original manifest is not too large, its
top-level index table can be used as starting point for the new one
which is extended by one leaf pointer. In any case a new manifest
object is created which also needs a new name.

Note that the new manifest's name usually will differ (e.g. in the
version name component) and that the new manifest might need to carry
an explicit locator entry in the metadata section in order to make the
(old) leaf objects accessible.

--- back
