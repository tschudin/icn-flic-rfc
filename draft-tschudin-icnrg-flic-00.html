<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>File-Like ICN Collection (FLIC)</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
      /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
      a.info {
          /* This is the key. */
          position: relative;
          z-index: 24;
          text-decoration: none;
      }
      a.info:hover {
          z-index: 25;
          color: #FFF; background-color: #900;
      }
      a.info span { display: none; }
      a.info:hover span.info {
          /* The span will display just on :hover state. */
          display: block;
          position: absolute;
          font-size: smaller;
          top: 2em; left: -5em; width: 15em;
          padding: 2px; border: 1px solid #333;
          color: #900; background-color: #EEE;
          text-align: left;
      }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  max-width: 55em;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 FLIC as a Distributed Data Structure"/>
<link href="#rfc.section.1.2" rel="Chapter" title="1.2 Design goals"/>
<link href="#rfc.section.2" rel="Chapter" title="2 File-Like ICN Collection (FLIC) Format"/>
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Use of hash-valued pointers"/>
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 Creating a FLIC data structure"/>
<link href="#rfc.section.2.3" rel="Chapter" title="2.3 Reconstructing the collection&#x2019;s data"/>
<link href="#rfc.section.2.4" rel="Chapter" title="2.4 Metadata in HashGroups"/>
<link href="#rfc.section.2.5" rel="Chapter" title="2.5 Locating FLIC leaf and manifest nodes"/>
<link href="#rfc.section.3" rel="Chapter" title="3 Advanced uses of FLIC manifests"/>
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Block-level de-duplification"/>
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Growing ICN collections"/>
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Re-publishing a FLIC under a new name"/>
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 Data Chunks of variable size"/>
<link href="#rfc.section.4" rel="Chapter" title="4 Encoding"/>
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Encoding for CCNx1.0"/>
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Encoding for NDN"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.5.0 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Tschudin, C. and C. Wood" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-tschudin-icnrg-flic-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2015-12-08" />
  <meta name="dct.abstract" content="This document describes a bare bones &#8220;index table&#8221;-approach for organizing a set of ICN data objects into a large, File-Like ICN Collection (FLIC)." />
  <meta name="description" content="This document describes a bare bones &#8220;index table&#8221;-approach for organizing a set of ICN data objects into a large, File-Like ICN Collection (FLIC)." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">ICNRG Working Group</td>
  <td class="right">C. Tschudin</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">University of Basel</td>
</tr>
<tr>
  <td class="left">Intended status: Informational</td>
  <td class="right">C. Wood</td>
</tr>
<tr>
  <td class="left">Expires: June 10, 2016</td>
  <td class="right">PARC, Inc.</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">December 08, 2015</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">File-Like ICN Collection (FLIC)<br />
  <span class="filename">draft-tschudin-icnrg-flic-00</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>This document describes a bare bones &#8220;index table&#8221;-approach for organizing a set of ICN data objects into a large, File-Like ICN Collection (FLIC).</p>
<p>At the core of this collection is a so called manifest which acts as the collection&#8217;s root node. The manifest contains an index table with pointers, each pointer being a hash value pointing to either a final data block or another index table node.</p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on June 10, 2016.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2015 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<ul><li>1.1.   <a href="#rfc.section.1.1">FLIC as a Distributed Data Structure</a></li>
<li>1.2.   <a href="#rfc.section.1.2">Design goals</a></li>
</ul><li>2.   <a href="#rfc.section.2">File-Like ICN Collection (FLIC) Format</a></li>
<ul><li>2.1.   <a href="#rfc.section.2.1">Use of hash-valued pointers</a></li>
<li>2.2.   <a href="#rfc.section.2.2">Creating a FLIC data structure</a></li>
<li>2.3.   <a href="#rfc.section.2.3">Reconstructing the collection&#8217;s data</a></li>
<li>2.4.   <a href="#rfc.section.2.4">Metadata in HashGroups</a></li>
<li>2.5.   <a href="#rfc.section.2.5">Locating FLIC leaf and manifest nodes</a></li>
</ul><li>3.   <a href="#rfc.section.3">Advanced uses of FLIC manifests</a></li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Block-level de-duplification</a></li>
<li>3.2.   <a href="#rfc.section.3.2">Growing ICN collections</a></li>
<li>3.3.   <a href="#rfc.section.3.3">Re-publishing a FLIC under a new name</a></li>
<li>3.4.   <a href="#rfc.section.3.4">Data Chunks of variable size</a></li>
</ul><li>4.   <a href="#rfc.section.4">Encoding</a></li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Encoding for CCNx1.0</a></li>
<li>4.2.   <a href="#rfc.section.4.2">Encoding for NDN</a></li>
</ul><li><a href="#rfc.authors">Authors' Addresses</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> <a href="#problems" id="problems">Introduction</a></h1>
<h1 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1.</a> <a href="#flic-as-a-distributed-data-structure" id="flic-as-a-distributed-data-structure">FLIC as a Distributed Data Structure</a></h1>
<p id="rfc.section.1.1.p.1">One figure</p>
<div id="rfc.figure.1"/>
<div id="manifest"/>
<pre>
                          root manifest
  .------------------------------------.
  | optional name:                     |
  |   /icn/name/of/this/flic           |
  |                                    |
  | HashGroup:                         |
  |   optional metadata:               |
  |     block size, total tree size,   |       leaf
  |     overall digest, locator, etc.  |    .------.
  |   hash-valued data pointer -----------&gt; | data |
  |     ...                            |    `------'  sub manifest
  |   hash-valued manifest pointer ------.     .------------------.
  |                                    |  `--&gt; |                -----&gt;
  | optional additional HashGroups ..  |       |                -----&gt;
  |                                    |       `------------------'
  | optional signature                 |
  `------------------------------------'
</pre>
<p class="figure">Figure 1: A FLIC manifest and its directed acyclic graph</p>
<h1 id="rfc.section.1.2"><a href="#rfc.section.1.2">1.2.</a> <a href="#design-goals" id="design-goals">Design goals</a></h1>
<p/>

<ul>
  <li>Copy the proven UNIX inode concept: <ul><li>index tables and memory pointers</li></ul></li>
  <li>Adaption to ICN: <ul><li>hash values instead of block numbers, unique with high probability</li></ul></li>
  <li>Advantages (over non-manifest collections): <ul><li>single root manifest signature covers all elements of the full collection, including intermediate sub manifests</li><li>eliminate reference to chunk numbering schemata (hash values only)</li><li>supports block-level deduplification (can lead to a directed acyclic graph, or DAG, instead of a tree)</li></ul></li>
  <li>Limitations <ul><li>All data leafs must be present at manifest creation time (otherwise one cannot compute the pointers)</li></ul></li>
  <li>Potential extensions (for study): <ul><li>Enhance the manifest such that it can serve as a &#8220;database cursor&#8221; or as a cursor over a time series, e.g. having entries for &#8220;previous&#8221; and &#8220;next&#8221; collections.</li></ul></li>
</ul>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#file-like-icn-collection-flic-format" id="file-like-icn-collection-flic-format">File-Like ICN Collection (FLIC) Format</a></h1>
<p id="rfc.section.2.p.1">We first give the FLIC format in EBN notation:</p>
<pre>
   ManifestMsg := Name? HashGroup+
   HashGroup   := MetaData? (DataPointer | ManifestPtr)+
   DataPointer := HashValue
   ManifestPtr := HashValue
   HashValue   := OCTET[32]

   MetaData    := Property*
   Property    := Locator | DataBlockSize | OverallDataSize |
                  OverallDataSHA256Digest | ...
</pre>
<p id="rfc.section.2.p.2">Description:</p>
<p/>

<ul>
  <li>The core of a manifest is the sequence of &#8220;hash groups&#8221;.</li>
  <li>A HashGroup consists of a sequence of data or manifest pointers.</li>
  <li>Data as well as manifest pointers are SHA256 digests (32 Bytes); their encoding assigns them distinct types.</li>
  <li>A HashGroup can contain a metadata section to help a reader to optimize content retrieval (block size of leaf nodes, total size, overall digest etc).</li>
  <li>None of the ICN objects used in FLIC are allowed to be chunked, including the (sub-) manifests. The smallest possible complete manifest contains one HashGroup with one pointer to an ICN object.</li>
</ul>
<h1 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1.</a> <a href="#use-of-hash-valued-pointers" id="use-of-hash-valued-pointers">Use of hash-valued pointers</a></h1>
<p id="rfc.section.2.1.p.1">FLIC&#8217;s tree data structure is a generalized index table as it is known from file systems. The pointers, which in an OS typically are harddisk block numbers, are replaced by hash values of other ICN objects. These ICN objects contain either other manifest nodes, or leaf nodes. Leafs contain the actual data of the collection.</p>
<p id="rfc.section.2.1.p.2">FLIC makes use of &#8220;nameless ICN object&#8221; where the network is tasked with fetching an object based on its digest only. The interest for such an object consists of a routing hint (locator) plus the given digest value.</p>
<h1 id="rfc.section.2.2"><a href="#rfc.section.2.2">2.2.</a> <a href="#creating-a-flic-data-structure" id="creating-a-flic-data-structure">Creating a FLIC data structure</a></h1>
<p id="rfc.section.2.2.p.1">Starting from the original content, the corresponding byte array is sliced into chunks (of equal size if blocksize is present in the metadata section, except for the last chunk). Each chunk is encoded as a data object, according the ICN suite.  For each resulting data object, the hash value is computed. Groups of consecutive objects are formed and the corresponding hash values collected in manifests, which are also encoded. The hash values of the manifest objects replace the hash values of the covered leaf nodes, thus reducing the number of hash values. This process of hash value collection and replacement is repeated until only one (root) manifest is left.</p>
<pre>
data1 &lt;-- h1  -  -  -  -  -  -  -  -  -  -  -  - \
data2 &lt;-- h2 \                                    root mfst
...            mfst 1 &lt;-- hN+1  \                /
dataJ &lt;-- hJ /                    mfst2 &lt;-- hN+2
...                              /
dataN &lt;-- hN  -  -  -  -  -  -  /
</pre>
<p id="rfc.section.2.2.p.2">Of special interest are &#8220;skewed trees&#8221; where a pointer to a manifest may only appear as last pointer of (sub-) manifests. Such a tree becomes a sequential list of manifests with a maximum of datapointers per manifest packet. Beside the tree shape we also show this data structure in form of packet content where D stands for a data pointer and M is the hash of a manifest packet.</p>
<pre>
data1   &lt;-- h1  -  -  -  -  -  -  -  -  root mfst
...                                    /
dataJ-1 &lt;-- hJ-1                      /
dataJ   &lt;-- hJ  -  -  mfst1 &lt;-- hN+1 /
...                /
dataN   &lt;-- hN  - /

DDDDDDM--&gt; DDDDDDM--&gt; ....... DDDDDDM--&gt; DDDDDDD
</pre>
<p id="rfc.section.2.2.p.3">A pseudo code description for producing a skewed tree follows below.</p>
<pre>
Input:
    Application data D of size |D| (bytes)
    Block size B (in bytes)
Output:
    FLIC root node R
Algo:
    n = number of leaf nodes = ceil(|D| / B)
    k = number of (encoded) hash values fitting in a block of size B
    H[1..n] = array of hash values
      initialized with the data hash values for data chunks 1..n
    While n &gt; k do
      a)  create manifest M with a HashGroup
      b)  append to the HashGroup in M all hash values H[n-k+1..n]
      c)  n = n - k + 1
      d)  H[n] = manifest hash value of M
    Create root manifest R with a HashGroup
    Add to the HashGroup of R all hash values H[1..n]
    Optionally: add name to R, sign manifest R
    Output R
</pre>
<p id="rfc.section.2.2.p.4">Obtaining with each manifest a maximum of data pointers is benefitial for keeping the download pipeline filled. On the other hand, this tree doesn&#8217;t support well random access to arbitrary byte positions: All data pointers coming before that offset have to be fetched before locating the block of interest. For random access, binary trees (where both subtrees of a node cover half of the content bytes) are better suited. This can be combined with the &#8220;skewed tree&#8221; approach: Manifests of intermediate nodes are filled with data pointers except for the last two slots. The second last slot points to a manifest for the &#8220;first half&#8221; of the left content, the last slots then points to a manifest for the rest.</p>
<pre>
root manifest=     DDDDDMM
           ____________/  \_____
          /                     \
          DDDDDMM                DDDDDMM
       _______/  \              _____/  \
      /           \            /         \
      DDDDDDD      DDDDDDD     DDDDDDD    DDDDDDD
</pre>
<h1 id="rfc.section.2.3"><a href="#rfc.section.2.3">2.3.</a> <a href="#reconstructing-the-collections-data" id="reconstructing-the-collections-data">Reconstructing the collection&#8217;s data</a></h1>
<p id="rfc.section.2.3.p.1">To fetch the data associated with a given FLIC (sub-) manifest, the receiver sequentially works through all entries found in the HashGroups and issues corresponding hash-based interests. In case of a data hash pointer, the received content object is appended. In case of a manifest hash pointer, this procedure is called recursively for the received manifest. In other words, the collection data is represented as the concatenation of data leaves from this &#8220;depth-first search&#8221; (DFS) traversal strategy of the manifest tree. This procedure works regardless of the tree&#8217;s shape.</p>
<p id="rfc.section.2.3.p.2">A pseudo code description for fetching is below.</p>
<pre>
Input:
    Root manifest R
Output:
    Application data D
Algo:
    global D = []
    DFS(R)
    Output D

where:

procedure DFS(M)
{
L:
  H = sequence of hash valued pointers of M
  foreach p in H do:
    if p is a data pointer then
      data = lookup(p)
      Append data to D
    else
      M = lookup(p)
      if p is last element in H then
        goto L;   // tail recursion
      DFS(M)
}
</pre>
<p id="rfc.section.2.3.p.3">The above DFS code works for FLIC manifest trees of arbitrary shape. In case of a skewed tree, no recursion is needed and a single instance of the DFS procedure suffices (tail recursion).</p>
<h1 id="rfc.section.2.4"><a href="#rfc.section.2.4">2.4.</a> <a href="#metadata-in-hashgroups" id="metadata-in-hashgroups">Metadata in HashGroups</a></h1>
<p id="rfc.section.2.4.p.1">In FLIC, metadata is linked to HashGroups and permits to inform the FLIC retriever about properties of the data that is covered by this hash group. Examples are overall data bytes or the block size used at production time. The intent of such metadata is to enable an in-network retriever to optimize its operation - other attributes linked to the collection as a whole (author, copyright etc) is out of scope.</p>
<p id="rfc.section.2.4.p.2">The list of available metadata is below.</p>
<pre>
* total length in bytes - permits to skip retrieving this hash group
  if the offset of interest is bigger

* child node block size - permits to jump to a specific data hash
  pointer of this group (if all pointers are data hash pointers)

* overall application data digest - provides a way to check correct
  reconstruction of the subtree associated with this hash group
  (before having reconstructed the full signed FLIC)

* tree depth - permits a receiver to predict the amount of memory
  needed when traversing this tree.

* locator value - provides a new routing hint (name prefix) where the
  chunks of this hash group can be retrieved from. The default is to
  use the locator of the root manifest.
</pre>
<h1 id="rfc.section.2.5"><a href="#rfc.section.2.5">2.5.</a> <a href="#locating-flic-leaf-and-manifest-nodes" id="locating-flic-leaf-and-manifest-nodes">Locating FLIC leaf and manifest nodes</a></h1>
<p id="rfc.section.2.5.p.1">The optional name of a manifest is a mere decoration and has no locator functionality at all: All objects pointed to by a manifest are retrieved from the location where the manifest itself was obtained from (which is not necessarily its name). Example:</p>
<pre>
Objects:
  manifest(name=/a/b/c, ptr=h1, ptr=hN)  - has hash h0
  nameless(data1)                        - has hash h1
  ...
  nameless(dataN)                        - has hash hN

Query for the manifest:
  interest(name=/the/locator/hint, implicitDigest=h0)
</pre>
<p id="rfc.section.2.5.p.2">In this example, the name &#8220;/a/b/c&#8221; does NOT override &#8220;/the/locator/hint&#8221; i.e., after having obtained the manifest, the retriever will issue requests for</p>
<pre>
  interest(name=/the/locator/hint, implicitDigest=h1)
  ...
  interest(name=/the/locator/hint, implicitDigest=hN)
</pre>
<p id="rfc.section.2.5.p.3">Using the locator metadata entry, this behavior can be changed:</p>
<pre>
Objects:
  manifest(name=/a/b/c,
           hashgroup(loc=/x/y/z, ptr=h1)
           hashgroup(ptr=h2)             - has hash h0
  nameless(data1)                        - has hash h1
  nameless(data2)                        - has hash h2

Queries:
  interest(name=/the/locator/hint, implicitDigest=h0)
  interest(name=/x/y/z, implicitDigest=h1)
  interest(name=/the/locator/hint, implicitDigest=h2)
</pre>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#advanced-uses-of-flic-manifests" id="advanced-uses-of-flic-manifests">Advanced uses of FLIC manifests</a></h1>
<p id="rfc.section.3.p.1">The FLIC mechanics has uses cases beyond keeping together a set of data objects:</p>
<h1 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a> <a href="#block-level-de-duplification" id="block-level-de-duplification">Block-level de-duplification</a></h1>
<p id="rfc.section.3.1.p.1">Consider a huge file, e.g. an ISO image of a DVD or program in binary form, that had previously been FLIC-ed but now needs to be patched.  In this case, all existing encoded ICN chunks can remain in the repository while only the chunks for the patch itself is added to a new manifest data structure, as is shown in the picture below. For example, the <a href="http://plan9.bell-labs.com/sys/doc/venti/venti.pdf">venti</a> archival file system of Plan9 uses this technique.</p>
<pre>
old_mfst -  - &gt; h1 --&gt; oldData1  &lt;-- h1 &lt; -  -  new_mfst
         \  - &gt; h2 --&gt; oldData2  &lt;-- h2 &lt; -  - /
          \            replace3  &lt;-- h5 &lt; -  -/
           \- &gt; h3 --&gt; oldData3              /
            \ &gt; h4 --&gt; oldData4  &lt;-- h4 &lt; - /
</pre>
<h1 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2.</a> <a href="#growing-icn-collections" id="growing-icn-collections">Growing ICN collections</a></h1>
<p id="rfc.section.3.2.p.1">A log file, for example, grows over time. Instead of having to re-FLIC the grown file it suffices to construct a new manifest with a manifest pointer to the old root manifest plus the sequence of data hash pointers for the new data (or additional sub-manifests if necessary).  Note that this tree will not be skewed (anymore).</p>
<pre>
old data &lt; -  -  -  mfst_old &lt;-- h_old -  - mfst_new
                                            /
new data1 &lt;-- h_1 -  -  -  -  -  -  -  -  -/
new data2                                 /
...                                      /
new dataN &lt;-- h_N -  -  -  -  -  -  -  -/
</pre>
<h1 id="rfc.section.3.3"><a href="#rfc.section.3.3">3.3.</a> <a href="#re-publishing-a-flic-under-a-new-name" id="re-publishing-a-flic-under-a-new-name">Re-publishing a FLIC under a new name</a></h1>
<p id="rfc.section.3.3.p.1">It can happen that a publisher&#8217;s namespace is part of a service provider&#8217;s prefix. When switching provider, the publisher may want to republish the old data under a new name. This can easily be achieved with a single nameless root manifest for the large FLIC plus arbitrarily many per-name manifests (which are signed by whomever wants to publish this data):</p>
<pre>
   data &lt; - nameless_mfst() &lt;-- h  &lt; - mfst(/com/parc/east/the/flic)
                                   &lt; - mfst(/com/parc/west/old/the/flic)
                                   &lt; - mfst(/internet/archive/flic234)
</pre>
<p id="rfc.section.3.3.p.2">Note that the hash computation (of h) only requires reading the nameless root manifest, not the entire FLIC.</p>
<p id="rfc.section.3.3.p.3">This example points out the problem of HashGroups having locator metadata elements: A retriever would be urged to follow these hints which are &#8220;hardcoded&#8221; deep inside the FLIC but might have become outdated. We therefore recommend to name FLIC manifests only at the highest level (where these names have no locator function). Child nodes in a FLIC manifest should not be named as these names serve no purpose except retrieving a sub-tree&#8217;s manifest by name, if would be required.</p>
<h1 id="rfc.section.3.4"><a href="#rfc.section.3.4">3.4.</a> <a href="#data-chunks-of-variable-size" id="data-chunks-of-variable-size">Data Chunks of variable size</a></h1>
<p id="rfc.section.3.4.p.1">If chunks do not have regular (block) sizes, the HashGroup can be used to still convey to a reader the length of the chunks, at manifest level. Example use cases would be chunks each carrying a single ASCII line as entered by a user, or a database with variable length records mapped to chunks.</p>
<pre>
M = (manifest
      (hashgroup((metadata(blocksize=12)) (dataptr=h1))
      (hashgroup((metadata(blocksize=1)) (dataptr=h2))
      ...
    )
</pre>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#encoding" id="encoding">Encoding</a></h1>
<p id="rfc.section.4.p.1">We express the packet encoding of manifests in a symbolic expression style in order to show the TLV structure and the chosen type values. In this notation, a TLV&#8217;s type is a combination of &#8220;SymbolicName/Tvalue&#8221;, Length is not shown and Values are sub-expressions. Moreover, we populate the data structure with all possible entries and omit repetition. An abbreviated example for the NDN Interest packet would be:</p>
<pre>
(Interest/0x5
  (Name/0x7 (NameComp=0x8 ...) ...)
  (Selector/0x9 ...)
  (Nonce/0xA BLOB)
  (Scope/0xB INT)
  (InterestLifeTime/0xC INT)
)
</pre>
<h1 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1.</a> <a href="#encoding-for-ccnx10" id="encoding-for-ccnx10">Encoding for CCNx1.0</a></h1>
<pre>
[FIXED_HEADER OCTET[8]]
(ManifestMsg/0x6
  (Name/0x0 ...)
  (HashGroup/0x1
     (MetaData/0x1
        (LocatorNm/0x0 (NameComp/0x ...))
        (BlockSize/0x2 INT)
        (TotalSize/0x3 INT)
        (TotalHash/0x4 OCTET[32])
     )
     (DataPtr/0x2 OCTET[32])
     (MfstPtr/0x3 OCTET[32])
  )
)
</pre>
<p id="rfc.section.4.1.p.1">Interest: name is locator, use objHashRestriction as selector</p>
<h1 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2.</a> <a href="#encoding-for-ndn" id="encoding-for-ndn">Encoding for NDN</a></h1>
<p id="rfc.section.4.2.p.1">The assigned NDN content type value for FLIC manifests is 1024 (0x400).</p>
<pre>
(Data/0x6
  (Name/0x7 ...)
  (MetaInfo/0x14
    (ContentType/0x18 0x0400)
  )
  (Content/0x15
    (HashGroup/0xC0
      (MetaInfo/0x14
        (LocatorNm/0xC3 (NameComp/0x8 ...))
        (TotalHash/0xC4 OCTET[32])
        (TotalSize/0xC5 INT)
        (BlockSize/0xC6 INT)
        (TreeDepth/0xC7 INT)
      )
      (DataPtr/0xC1 OCTET[32])
      (MfstPtr/0xC2 OCTET[32])
    )
  )
  (SignatureInfo/0x16 ...)
  (SignatureValue/0x17 ...)
)
</pre>
<p id="rfc.section.4.2.p.2">Interest: name is locator, use implicitDigest name component as selector</p>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Authors' Addresses</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Christian Tschudin</span> 
	  <span class="n hidden">
		<span class="family-name">Tschudin</span>
	  </span>
	</span>
	<span class="org vcardline">University of Basel</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:christian.tschudin@unibas.ch">christian.tschudin@unibas.ch</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Christopher A. Wood</span> 
	  <span class="n hidden">
		<span class="family-name">Wood</span>
	  </span>
	</span>
	<span class="org vcardline">PARC, Inc.</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:christopher.wood@parc.com">christopher.wood@parc.com</a></span>

  </address>
</div>

</body>
</html>
